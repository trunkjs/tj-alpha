import { describe, it, beforeEach, expect } from 'vitest';
import { ContentBuilder } from '../ContentBuilder';

/**
 * Utility helper â€“ expects that the given heading / hr element
 * is wrapped inside a <section> with the provided `i` value
 * and that section for further nested assertions.
 */
function expectWrappedBySection(
    element: HTMLElement,
    expectedTag: string,
    expectedI: string
): HTMLElement {
    const section = element.parentElement as HTMLElement;
    expect(section, `Element ${element.tagName} should have a parent`).not.toBeNull();
    expect(section.tagName.toLowerCase()).toBe(expectedTag);
    expect(section.getAttribute('i')).toBe(expectedI);
    return section;
}

describe('ContentBuilder arrangement based on example tj-content-area.html', () => {
    let area: HTMLElement;

    const markup = `
        <tj-content-area>

            <h1 layout="xtag.some-class">H1 Element</h1>

            <p>This is a paragraph of text.</p>
            <p>This is another paragraph of text.</p>

            <h2>H2 Element</h2>
            <p>This is a paragraph of text.</p>

            <h2>H2 Element</h2>
            <p>This is a paragraph of text.</p>
            <p>This is another paragraph of text.</p>
            <h3>H3 Element</h3>
            <p>This is a paragraph of text.</p>
            <p>This is another paragraph of text.</p>
            <h4>H4 Element</h4>
            <p>This is a paragraph of text.</p>
            <p>This is another paragraph of text.</p>
            <h3>H5 Element</h3>
            <p>This is a paragraph of text.</p>

        </tj-content-area>
    `;

    beforeEach(() => {
        // Reset DOM
        document.body.innerHTML = markup;
        area = document.querySelector('tj-content-area') as HTMLElement;

        // Run ContentBuilder on the children of <tj-content-area>
        const builder = new ContentBuilder(area);
        builder.arrange(Array.from(area.children));
    });

    it('wraps <h1> into its own section with i="2.0" on root level', () => {
        const h1 = area.querySelector('h1') as HTMLElement;
        const section = expectWrappedBySection(h1, 'xtag', '2.0');

        // section itself has to be direct child of the root element
        expect(section.parentElement).toBe(area);

        // The paragraphs that followed the h1 in the markup should reside inside the same section
        const ps = Array.from(section.querySelectorAll('p')).map(p => p.textContent?.trim());
        expect(ps).toEqual(
            expect.arrayContaining([
                'This is a paragraph of text.',
                'This is another paragraph of text.',
            ])
        );
    });

    it('wraps the first <h2> into its own sibling section with i="2.0"', () => {
        const h2elements = Array.from(area.querySelectorAll('h2'));
        const h2First = h2elements[0] as HTMLElement;
        const section = expectWrappedBySection(h2First, "section",'2.0');

        // Must also be placed directly under root (sibling of the h1-section)
        expect(section.parentElement).toBe(area);
    });

    it('places nested headings (h3/h4) correctly underneath second <h2>', () => {
        const h2Second = Array.from(area.querySelectorAll('h2'))[1] as HTMLElement;
        const h2Section = expectWrappedBySection(h2Second, '2.0');

        // ---- first nested h3  -------------------------------------------------
        const h3First = Array.from(area.querySelectorAll('h3')).find(h =>
            h.textContent?.includes('H3 Element')
        ) as HTMLElement;
        const h3FirstSection = expectWrappedBySection(h3First, '3.0');
        expect(h3FirstSection.parentElement).toBe(h2Section);

        // ---- h4 nested inside that h3 ----------------------------------------
        const h4 = area.querySelector('h4') as HTMLElement;
        const h4Section = expectWrappedBySection(h4, '4.0');
        expect(h4Section.parentElement).toBe(h3FirstSection);

        // ---- second h3 (H5 Element) should be sibling of first h3 ------------
        const h3Second = Array.from(area.querySelectorAll('h3')).find(h =>
            h.textContent?.includes('H5 Element')
        ) as HTMLElement;
        const h3SecondSection = expectWrappedBySection(h3Second, '3.0');
        expect(h3SecondSection.parentElement).toBe(h2Section);
    });

    it('creates dedicated sections for hr markers and handles + modifier (APPEND)', () => {
        // Section generated by <hr i="2">
        const hr2Section = area.querySelector('section[i="2.0"] hr[i="2"]')?.parentElement as HTMLElement;
        expect(hr2Section).not.toBeNull();
        expect(hr2Section.getAttribute('i')).toBe('2.0');
        // hr element should be hidden
        const hr2 = hr2Section.querySelector('hr[i="2"]') as HTMLElement;
        expect(hr2.getAttribute('hidden')).toBe('true');

        // Section generated by <hr i="2.5">
        const section25 = area.querySelector('section[i="2.5"]') as HTMLElement;
        expect(section25).not.toBeNull();
        const hr25 = section25.querySelector('hr[i="2.5"]') as HTMLElement;
        expect(hr25).not.toBeNull();
        expect(hr25.getAttribute('hidden')).toBe('true');

        // <hr i="+2"> should have been APPEND-ed to existing 2.5 section
        const hrPlus = hr2Section.querySelector('p[class="plus2"]') as HTMLElement;
        expect(hrPlus).not.toBeNull();


    });

    it('transfers section-* and layout-* attributes from heading to wrapper section', () => {
        const h1 = area.querySelector('h1') as HTMLElement;
        const section = h1.parentElement as HTMLElement;

        // Attributes should be moved to section (and removed from h1)
        expect(section.getAttribute('class')).toBe('some-class');
        expect(section.getAttribute('layout')).toBe('use: xtag');
        expect(section.getAttribute('key')).toBe('val1');

        expect(h1.hasAttribute('section-class')).toBe(false);
        expect(h1.hasAttribute('layout')).toBe(false);
        expect(h1.hasAttribute('layout-key')).toBe(false);
    });

    it('moves additional attributes from <hr> markers to their wrapper section', () => {
        const hr = area.querySelector('hr[i="2"]') as HTMLElement;
        const section = hr.parentElement as HTMLElement;

        expect(section.getAttribute('class')).toBe('some-class1');
        expect(hr.hasAttribute('class')).toBe(false);
    });

    it('does not remove any original content nodes (headings, paragraphs, hrs)', () => {
        // Number of headings, paragraphs and hr elements should match original markup
        const headingCountOriginal = 1 /*h1*/ + 2 /*h2*/ + 2 /*h3*/ + 1 /*h4*/;
        const hrCountOriginal = 3; // hr 2, hr 2.5, hr +2
        const pCountOriginal = 14; // paragraphs in the markup

        expect(area.querySelectorAll('h1, h2, h3, h4').length).toBe(headingCountOriginal);
        expect(area.querySelectorAll('hr').length).toBe(hrCountOriginal);
        expect(area.querySelectorAll('p').length).toBeGreaterThanOrEqual(pCountOriginal);
    });
});
